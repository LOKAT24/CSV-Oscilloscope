<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wydajny Wykres Canvas z Analizą FFT</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .header {
            flex-shrink: 0;
            padding: 10px 20px;
            background-color: #2a2a2a;
            text-align: center;
            border-bottom: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .main-controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            padding: 10px 0;
        }
        .control-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            border: 1px solid #444;
            padding: 10px 15px;
            border-radius: 8px;
            background-color: #333;
        }
        .section-title {
            font-weight: bold;
            color: #00aaff;
            margin-bottom: 5px;
            font-size: 1em;
            width: 100%;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        h1 {
            margin: 0 0 5px 0;
            color: #ffffff;
            font-size: 1.5em;
        }
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            font-family: inherit;
            transition: background-color 0.3s;
            width: 100%;
            box-sizing: border-box;
        }
        .btn svg {
            width: 16px;
            height: 16px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .btn.active {
            background-color: #0056b3;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        #file-input {
            display: none;
        }
        .radio-group {
            display: flex;
            background-color: #444;
            border-radius: 5px;
            overflow: hidden;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.3s;
            color: #ccc;
            font-size: 0.9em;
        }
        .radio-group svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        .radio-group input[type="radio"] { display: none; }
        .radio-group input[type="radio"]:checked + svg + span { color: #fff; }
        .radio-group label:has(input:checked) { background-color: #007bff; }
        #status {
            font-size: 0.9em;
            color: #bbb;
            min-height: 1.1em;
            width: 100%;
        }
        #separator-info {
            font-size: 0.8em;
            color: #888;
            min-height: 1em;
            margin-top: -5px;
        }
        .slider-control, .fft-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ccc;
            font-size: 0.9em;
        }
        .fft-control input, .fft-control select {
            background-color: #222;
            color: #eee;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 4px;
            font-family: inherit;
            font-size: 0.9em;
        }
        .fft-control input {
            width: 60px;
        }
        #density-info {
            font-family: monospace;
            font-size: 0.9em;
            background-color: #222;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 100px;
            text-align: center;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            min-height: 0;
        }
        canvas {
            display: block;
            background-color: #222;
            border-radius: 4px;
            width: 100%;
            height: 100%;
        }
        .panel {
            position: absolute;
            background-color: rgba(40, 40, 40, 0.8);
            border: 1px solid #666;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            font-family: monospace;
            color: #eee;
            pointer-events: none;
            display: none;
        }
        #measurements-panel {
            top: 10px;
            right: 10px;
        }
        #auto-measurements-panel {
            top: 10px;
            left: 10px;
        }
        #fft-peaks-panel {
            top: 150px;
            right: 10px;
            display: none;
        }
        #tooltip-panel {
            position: fixed; /* Używamy fixed, aby pozycjonować względem okna przeglądarki */
            display: none;
            pointer-events: none; /* Kluczowe, aby panel nie przechwytywał zdarzeń myszy */
            z-index: 10;
        }
        #hint-panel {
            bottom: 10px;
            left: 10px;
            pointer-events: all;
            display: block;
        }
        #hint-panel-close {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #555;
            color: #fff;
            border: 1px solid #888;
            border-radius: 50%;
            cursor: pointer;
            text-align: center;
            line-height: 18px;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Wizualizator Przebiegów CSV</h1>
        <div class="main-controls-container">
            <div class="control-section">
                <span class="section-title">Plik i Widok</span>
                <label for="file-input" class="btn">
                    <svg viewBox="0 0 24 24" style="fill:currentColor; stroke:none;"><path d="M4 4h7l2 2h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"></path></svg>
                    <span>Wybierz plik</span>
                </label>
                <input type="file" id="file-input" accept=".csv,.txt">
                <div id="separator-info"></div>
                <button id="reset-view-btn" class="btn">
                    <svg viewBox="0 0 24 24"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.2-3.2l-4.2 4.2A4 4 0 1 0 11 18.9V22h-1a10 10 0 0 1-8-10.5z"></path></svg>
                    <span>Resetuj Widok</span>
                </button>
            </div>
            <div class="control-section">
                <span class="section-title">Tryb Wyświetlania</span>
                <div class="radio-group" id="render-mode-controls">
                    <label>
                        <input type="radio" name="renderMode" value="minmax" checked>
                        <svg viewBox="0 0 24 24"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>
                        <span>Szybki</span>
                    </label>
                    <label>
                        <input type="radio" name="renderMode" value="points">
                        <svg viewBox="0 0 24 24" style="fill:currentColor; stroke:none;"><circle cx="12" cy="12" r="1.5"></circle><circle cx="19" cy="5" r="1.5"></circle><circle cx="5" cy="19" r="1.5"></circle><circle cx="5" cy="5" r="1.5"></circle><circle cx="19" cy="19" r="1.5"></circle></svg>
                        <span>Punkty</span>
                    </label>
                    <label>
                        <input type="radio" name="renderMode" value="line">
                        <svg viewBox="0 0 24 24"><polyline points="3 12 8 7 16 17 21 12"></polyline></svg>
                        <span>Linia</span>
                    </label>
                </div>
                 <div class="slider-control">
                     <label for="optimization-slider">Gęstość:</label>
                     <input type="range" id="optimization-slider" min="1" max="100" value="25">
                     <span id="density-info"></span>
                </div>
            </div>
            <div class="control-section">
                <span class="section-title">Narzędzia</span>
                <button id="cursors-toggle-btn" class="btn">
                    <svg viewBox="0 0 24 24"><path d="M4 9h16M4 15h16M9 4v16M15 4v16"></path></svg>
                    <span>Kursory</span>
                </button>
                <button id="auto-measure-toggle-btn" class="btn">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="5"></rect><rect x="14" y="7" width="3" height="5"></rect><line x1="7" y1="15" x2="17" y2="15"></line><line x1="10" y1="12" x2="14" y2="12"></line></svg>
                    <span>Pomiary Auto</span>
                </button>
                <button id="fft-toggle-btn" class="btn">
                    <svg viewBox="0 0 24 24"><path d="M3 3v18h18"></path><path d="M7 12h2l2-4 2 8 2-4h2"></path></svg>
                    <span>Analiza FFT</span>
                </button>
                 <div class="fft-control" id="fft-controls" style="display: none;">
                     <div>
                         <label for="fft-freq-input">Zakres:</label>
                         <input type="number" id="fft-freq-input" value="100">
                         <select id="fft-unit-select">
                             <option value="1">Hz</option>
                             <option value="1000" selected>kHz</option>
                             <option value="1000000">MHz</option>
                         </select>
                     </div>
                     <button id="fft-peaks-toggle-btn" class="btn">
                        <svg viewBox="0 0 24 24"><path d="M3 20h18L12 4z"></path></svg>
                        <span>Wykryj Piki</span>
                    </button>
                     <div id="fft-peaks-controls" style="display: none;">
                        <label for="fft-peaks-input">Liczba pików:</label>
                        <input type="number" id="fft-peaks-input" value="5" min="1" max="20" style="width: 50px;">
                     </div>
                </div>
            </div>
        </div>
        <div id="status">Wybierz plik, aby rozpocząć.</div>
    </div>

    <div id="canvas-container">
        <canvas id="plot-canvas"></canvas>
        <div id="measurements-panel" class="panel"></div>
        <div id="auto-measurements-panel" class="panel"></div>
        <div id="fft-peaks-panel" class="panel"></div>
        <div id="tooltip-panel" class="panel"></div>
        <div id="hint-panel" class="panel">
            <div id="hint-panel-close">&times;</div>
            <b>Wskazówki:</b><br>
            - Zoom X: Kółko myszy<br>
            - Zoom Y: Ctrl + Kółko<br>
            - Przesuń: Przeciągnij
        </div>
    </div>

    <script>
        // --- Elementy DOM ---
        const fileInput = document.getElementById('file-input');
        const statusDiv = document.getElementById('status');
        const separatorInfo = document.getElementById('separator-info');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('plot-canvas');
        const ctx = canvas.getContext('2d');
        const cursorsBtn = document.getElementById('cursors-toggle-btn');
        const autoMeasureBtn = document.getElementById('auto-measure-toggle-btn');
        const fftBtn = document.getElementById('fft-toggle-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const optimizationSlider = document.getElementById('optimization-slider');
        const measurementsPanel = document.getElementById('measurements-panel');
        const autoMeasurementsPanel = document.getElementById('auto-measurements-panel');
        const densityInfo = document.getElementById('density-info');
        const sliderControl = document.querySelector('.slider-control');
        const fftControls = document.getElementById('fft-controls');
        const fftFreqInput = document.getElementById('fft-freq-input');
        const fftUnitSelect = document.getElementById('fft-unit-select');
        const fftPeaksToggleBtn = document.getElementById('fft-peaks-toggle-btn');
        const fftPeaksControls = document.getElementById('fft-peaks-controls');
        const fftPeaksInput = document.getElementById('fft-peaks-input');
        const fftPeaksPanel = document.getElementById('fft-peaks-panel');
        const tooltipPanel = document.getElementById('tooltip-panel');
        const hintPanel = document.getElementById('hint-panel');
        const hintPanelClose = document.getElementById('hint-panel-close');

        // --- Globalne zmienne ---
        let allVoltages = [];
        let startTime = 0;
        let increment = 1e-9;
        let dataMinY = 0, dataMaxY = 0;
        let renderMode = 'minmax';
        let optimizationLevel = 25;
        const padding = { top: 20, right: 20, bottom: 40, left: 60 };

        // --- Stan widoku (transformacja) ---
        const view = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0, panning: false, lastMouseX: 0, lastMouseY: 0 };
        const fftView = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
        
        // --- Stan narzędzi ---
        const cursors = { enabled: false, v1: 0.75, v2: 0.25, t1: 0.25, t2: 0.75, dragging: null, hovering: null, grabDistance: 10 };
        const autoMeasurements = { enabled: false };
        const fftMode = { enabled: false, data: null, effectiveIncrement: 1 };
        const fftPeaks = { enabled: false, data: [], num: 5 };

        // --- Inicjalizacja ---
        function init() {
            setupCanvas();
            fileInput.addEventListener('change', handleFileSelect);
            
            document.querySelectorAll('input[name="renderMode"]').forEach(radio => {
                radio.addEventListener('change', function() { 
                    renderMode = this.value; 
                    sliderControl.style.display = renderMode === 'minmax' ? 'none' : 'flex';
                    draw(); 
                });
            });
            
            cursorsBtn.addEventListener('click', toggleCursors);
            autoMeasureBtn.addEventListener('click', toggleAutoMeasurements);
            fftBtn.addEventListener('click', toggleFFT);
            fftPeaksToggleBtn.addEventListener('click', toggleFFTPeaks);
            fftPeaksInput.addEventListener('change', (e) => {
                fftPeaks.num = parseInt(e.target.value, 10);
                if (fftPeaks.enabled) {
                    findFFTPeaks();
                    draw();
                }
            });

            resetViewBtn.addEventListener('click', () => { 
                if(allVoltages.length === 0) return;
                if (fftMode.enabled) { resetFFTView(); } 
                else { resetView(); }
                draw(); 
            });
            optimizationSlider.addEventListener('input', (e) => {
                optimizationLevel = parseInt(e.target.value, 10);
                draw();
            });
            
            const fftUpdateHandler = () => {
                if(fftMode.enabled) {
                    calculateFFT();
                    resetFFTView();
                    draw();
                }
            };
            fftFreqInput.addEventListener('change', fftUpdateHandler);
            fftUnitSelect.addEventListener('change', fftUpdateHandler);
            
            hintPanelClose.addEventListener('click', () => hintPanel.style.display = 'none');

            canvas.addEventListener('wheel', handleZoom);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', (e) => {
                handleMouseUp(e);
                tooltipPanel.style.display = 'none';
            });
            window.addEventListener('resize', setupCanvas);
            
            sliderControl.style.display = renderMode === 'minmax' ? 'none' : 'flex';
        }

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvasContainer.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        // --- Obsługa Plików ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            statusDiv.textContent = '⏳ Wczytywanie pliku...';
            separatorInfo.textContent = '';
            const reader = new FileReader();
            reader.onload = e => {
                statusDiv.textContent = '⚙️ Przetwarzanie danych... To może potrwać...';
                setTimeout(() => {
                    try {
                        parseData(e.target.result);
                        resetView();
                        draw();
                        statusDiv.textContent = `✅ Gotowe! Użyj kółka myszy do zoomu, przeciągnij by przesuwać.`;
                    } catch (error) {
                        statusDiv.textContent = `❌ Błąd: ${error.message}`;
                        separatorInfo.textContent = 'Sprawdź format pliku lub konsolę (F12).';
                        console.error(error);
                    }
                }, 50);
            };
            reader.readAsText(file);
        }

        function parseData(content) {
            const lines = content.split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length < 3) throw new Error("Plik jest zbyt krótki lub ma nieprawidłowy format.");
            let columnSeparator = ';', decimalSeparator = ',';
            const headerLine2 = lines[1];
            if (headerLine2.split(';').length >= 3) {
                columnSeparator = ';';
                decimalSeparator = headerLine2.split(';')[1].includes(',') ? ',' : '.';
            } else if (headerLine2.split(',').length >= 3) {
                columnSeparator = ',';
                decimalSeparator = '.';
            } else { throw new Error("Nie udało się automatycznie wykryć separatora kolumn."); }
            separatorInfo.textContent = `Separatory: Kolumna="${columnSeparator}" Dziesiętny="${decimalSeparator}"`;
            const parseNumber = (str) => parseFloat(str?.trim().replace(decimalSeparator, '.'));
            const metaLineParts = lines[1].trim().split(columnSeparator);
            startTime = parseNumber(metaLineParts[1]);
            increment = parseNumber(metaLineParts[2]);
            if (isNaN(startTime) || isNaN(increment)) throw new Error("Nie udało się odczytać metadanych.");
            allVoltages = new Float32Array(lines.length - 2);
            let count = 0;
            dataMinY = Infinity; dataMaxY = -Infinity;
            for (let i = 2; i < lines.length; i++) {
                const valueStr = lines[i].trim().split(columnSeparator)[0];
                if (valueStr) {
                    const v = parseNumber(valueStr);
                    if (!isNaN(v)) {
                        allVoltages[count++] = v;
                        if (v < dataMinY) dataMinY = v;
                        if (v > dataMaxY) dataMaxY = v;
                    }
                }
            }
            allVoltages = allVoltages.slice(0, count);
            if (allVoltages.length === 0) throw new Error("Nie znaleziono żadnych prawidłowych danych.");
        }
        
        // --- Logika Interakcji ---
        function resetView() {
            const { chartWidth, chartHeight } = getChartDimensions();
            
            const timeDuration = allVoltages.length * increment;
            view.scaleX = chartWidth / (timeDuration || 1);
            view.offsetX = -startTime * view.scaleX;

            const yRange = dataMaxY - dataMinY;
            view.scaleY = - (chartHeight / (yRange || 1));
            view.offsetY = chartHeight / 2 - ((dataMaxY + dataMinY) / 2) * view.scaleY;
        }

        function handleZoom(e) {
            e.preventDefault();
            if (cursors.dragging) return;
            const z = 1 + (e.deltaY < 0 ? 1 : -1) * 0.1;
            if (fftMode.enabled) {
                if (e.ctrlKey) {
                    const mouseY = e.offsetY - padding.top;
                    const db = (mouseY - fftView.offsetY) / fftView.scaleY;
                    fftView.scaleY *= z;
                    fftView.offsetY = mouseY - db * fftView.scaleY;
                } else {
                    const mouseX = e.offsetX - padding.left;
                    const freq = (mouseX - fftView.offsetX) / fftView.scaleX;
                    fftView.scaleX *= z;
                    fftView.offsetX = mouseX - freq * fftView.scaleX;
                }
            } else {
                if (e.ctrlKey) {
                    const mouseY = e.offsetY - padding.top;
                    const v = (mouseY - view.offsetY) / view.scaleY;
                    view.scaleY *= z;
                    view.offsetY = mouseY - v * view.scaleY;
                } else {
                    const mouseX = e.offsetX - padding.left;
                    const t = (mouseX - view.offsetX) / view.scaleX;
                    view.scaleX *= z;
                    view.offsetX = mouseX - t * view.scaleX;
                }
            }
            draw();
        }

        function handleMouseDown(e) {
            if (cursors.enabled && !fftMode.enabled) {
                const { chartWidth, chartHeight } = getChartDimensions();
                const mouseX = e.offsetX - padding.left;
                const mouseY = e.offsetY - padding.top;
                const dpr = window.devicePixelRatio || 1;
                const grabDist = cursors.grabDistance / dpr;
                if (Math.abs(mouseX - cursors.t1 * chartWidth) < grabDist) cursors.dragging = 't1';
                else if (Math.abs(mouseX - cursors.t2 * chartWidth) < grabDist) cursors.dragging = 't2';
                else if (Math.abs(mouseY - cursors.v1 * chartHeight) < grabDist) cursors.dragging = 'v1';
                else if (Math.abs(mouseY - cursors.v2 * chartHeight) < grabDist) cursors.dragging = 'v2';
            }
            if (!cursors.dragging) {
                view.panning = true;
                view.lastMouseX = e.offsetX;
                view.lastMouseY = e.offsetY;
            }
        }

        function handleMouseMove(e) {
            // Tooltip logic
            const rect = canvas.getBoundingClientRect();
            const mouseX_abs = e.offsetX;
            const mouseY_abs = e.offsetY;
            const mouseX_chart = mouseX_abs - padding.left;
            const mouseY_chart = mouseY_abs - padding.top;
            const { chartWidth, chartHeight } = getChartDimensions();

            if (mouseX_chart >= 0 && mouseX_chart <= chartWidth && mouseY_chart >= 0 && mouseY_chart <= chartHeight) {
                tooltipPanel.style.display = 'block';
                tooltipPanel.style.left = `${e.clientX + 15}px`;
                tooltipPanel.style.top = `${e.clientY + 15}px`;
                if (fftMode.enabled) {
                    const freq = (mouseX_chart - fftView.offsetX) / fftView.scaleX;
                    const db = (mouseY_chart - fftView.offsetY) / fftView.scaleY;
                    tooltipPanel.innerHTML = `${formatValue(freq, 'Hz')}<br>${db.toFixed(2)} dB`;
                } else {
                    const time = (mouseX_chart - view.offsetX) / view.scaleX;
                    const voltage = (mouseY_chart - view.offsetY) / view.scaleY;
                    tooltipPanel.innerHTML = `${formatValue(time, 's')}<br>${formatValue(voltage, 'V')}`;
                }
            } else {
                tooltipPanel.style.display = 'none';
            }

            // Panning and cursor logic
            if (view.panning) {
                const dx = e.offsetX - view.lastMouseX;
                const dy = e.offsetY - view.lastMouseY;
                if (fftMode.enabled) {
                    fftView.offsetX += dx;
                    fftView.offsetY += dy;
                } else {
                    view.offsetX += dx;
                    view.offsetY += dy;
                }
                view.lastMouseX = e.offsetX;
                view.lastMouseY = e.offsetY;
                draw();
            } else if (cursors.enabled && !fftMode.enabled) {
                const dpr = window.devicePixelRatio || 1;
                const grabDist = cursors.grabDistance / dpr;
                let hovering = null;
                if (Math.abs(mouseX_chart - cursors.t1 * chartWidth) < grabDist || Math.abs(mouseX_chart - cursors.t2 * chartWidth) < grabDist) {
                    hovering = 'col-resize';
                } else if (Math.abs(mouseY_chart - cursors.v1 * chartHeight) < grabDist || Math.abs(mouseY_chart - cursors.v2 * chartHeight) < grabDist) {
                    hovering = 'row-resize';
                }
                canvas.style.cursor = hovering || 'default';
            }
        }

        function handleMouseUp() {
            view.panning = false;
            cursors.dragging = null;
        }

        // --- Funkcje pomocnicze ---
        function getChartDimensions() {
            const { width, height } = canvas.getBoundingClientRect();
            return {
                chartWidth: width - padding.left - padding.right,
                chartHeight: height - padding.top - padding.bottom
            };
        }
        function getVisibleDataIndices() {
            const { chartWidth } = getChartDimensions();
            const startIndex = Math.max(0, Math.floor((-view.offsetX / view.scaleX - startTime) / increment));
            const endIndex = Math.min(allVoltages.length, Math.ceil(((chartWidth - view.offsetX) / view.scaleX - startTime) / increment));
            return { startIndex, endIndex };
        }
        function getBestTimeFit(range) {
            const absRange = Math.abs(range);
            if (absRange >= 1) return { multiplier: 1, unit: 's' };
            if (absRange >= 1e-3) return { multiplier: 1e3, unit: 'ms' };
            if (absRange >= 1e-6) return { multiplier: 1e6, unit: 'µs' };
            if (absRange >= 1e-9) return { multiplier: 1e9, unit: 'ns' };
            return { multiplier: 1e12, unit: 'ps' };
        }
        function getBestFreqFit(range) {
            const absRange = Math.abs(range);
            if (absRange >= 1e9) return { multiplier: 1e-9, unit: 'GHz' };
            if (absRange >= 1e6) return { multiplier: 1e-6, unit: 'MHz' };
            if (absRange >= 1e3) return { multiplier: 1e-3, unit: 'kHz' };
            return { multiplier: 1, unit: 'Hz' };
        }
        function formatValue(value, unit) {
            if (value === null || isNaN(value)) return '---';
            if (Math.abs(value) >= 1e12) return value.toExponential(2) + ' ' + unit;
            if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(2) + ' G' + unit;
            if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(2) + ' M' + unit;
            if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(2) + ' k' + unit;
            if (Math.abs(value) >= 1) return value.toFixed(2) + ' ' + unit;
            if (Math.abs(value) >= 1e-3) return (value * 1e3).toFixed(2) + ' m' + unit;
            if (Math.abs(value) >= 1e-6) return (value * 1e6).toFixed(2) + ' µ' + unit;
            if (Math.abs(value) >= 1e-9) return (value * 1e9).toFixed(2) + ' n' + unit;
            if (Math.abs(value) >= 1e-12) return (value * 1e12).toFixed(2) + ' p' + unit;
            if (value === 0) return '0 ' + unit;
            return value.toExponential(2) + ' ' + unit;
        }

        // --- Główna funkcja rysująca ---
        function draw() {
            const { width, height } = canvas.getBoundingClientRect();
            
            // Use a robust method to clear the entire canvas, ignoring transforms
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            if (allVoltages.length === 0) {
                ctx.fillStyle = "#666"; ctx.textAlign = "center"; ctx.font = "16px Arial";
                ctx.fillText("Brak danych do wyświetlenia. Wybierz plik.", width / 2, height / 2);
                densityInfo.textContent = '';
                return;
            }
            const { chartWidth, chartHeight } = getChartDimensions();
            
            ctx.save();
            ctx.translate(padding.left, padding.top);
            ctx.beginPath(); 
            ctx.rect(0, 0, chartWidth, chartHeight); 
            ctx.clip();
            
            if (fftMode.enabled) {
                if (!fftMode.data) calculateFFT();
                drawFFT(chartWidth, chartHeight);
            } else {
                drawWaveform(chartWidth, chartHeight);
                if (cursors.enabled) drawCursors(chartWidth, chartHeight);
            }
            
            ctx.restore();

            drawAxesAndLabels(width, height);

            if (cursors.enabled && !fftMode.enabled) updateMeasurementsPanel();
            if (autoMeasurements.enabled && !fftMode.enabled) updateAutoMeasurementsPanel();
            if (fftPeaks.enabled) updateFFTPeaksPanel();
        }

        function drawAxesAndLabels(width, height) {
            const { chartWidth, chartHeight } = getChartDimensions();
            
            // Draw Grids and Labels
            ctx.save();
            ctx.font = "10px Arial";
            ctx.fillStyle = "#888";
            ctx.translate(padding.left, padding.top);

            if (fftMode.enabled) {
                drawFreqAxis(chartWidth, chartHeight);
                drawDbAxis(chartWidth, chartHeight);
            } else {
                drawTimeAxis(chartWidth, chartHeight);
                drawVoltageAxis(chartWidth, chartHeight);
            }
            ctx.restore();

            // Draw Axis Titles
            ctx.save();
            ctx.font = "10px Arial";
            ctx.fillStyle = "#888";
            ctx.textAlign = "center";

            if (fftMode.enabled) {
                const freqRange = chartWidth / fftView.scaleX;
                const freqFit = getBestFreqFit(freqRange);
                ctx.fillText(`Częstotliwość [${freqFit.unit}]`, padding.left + chartWidth / 2, height - 5);
            } else {
                const timeRange = chartWidth / view.scaleX;
                const timeFit = getBestTimeFit(timeRange);
                ctx.fillText(`Czas [${timeFit.unit}]`, padding.left + chartWidth / 2, height - 5);
            }
            
            ctx.save();
            ctx.translate(padding.left - 45, padding.top + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(fftMode.enabled ? "Amplituda [dB]" : "Napięcie [V]", 0, 0);
            ctx.restore();

            ctx.restore();
        }

        function drawTimeAxis(width, height) {
            ctx.textAlign = "center";
            const timeRange = width / view.scaleX;
            const timeFit = getBestTimeFit(timeRange);
            let timeStep = Math.pow(10, Math.floor(Math.log10(timeRange))) / 10;
            if (timeStep < 1e-15) timeStep = 1e-15;
            const firstTime = -view.offsetX / view.scaleX;
            let time = Math.ceil(firstTime / timeStep) * timeStep;
            while(true) {
                const x = time * view.scaleX + view.offsetX;
                if (x > width + 10) break;
                if (x >= -10) {
                    const isZeroAxis = Math.abs(time) < 1e-12;
                    ctx.strokeStyle = isZeroAxis ? '#00aaff' : '#444';
                    ctx.lineWidth = isZeroAxis ? 1 : 0.5;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                    if(!isZeroAxis) {
                        const labelValue = (time * timeFit.multiplier).toFixed(2).replace(/\.00$/, '');
                        ctx.fillText(labelValue, x, height + 15);
                    }
                }
                time += timeStep;
                if (timeStep === 0 || !isFinite(timeStep)) break;
            }
        }

        function drawVoltageAxis(width, height) {
            ctx.textAlign = "right";
            const voltRange = height / Math.abs(view.scaleY);
            let voltStep = Math.pow(10, Math.floor(Math.log10(voltRange))) / 5;
            if (voltStep <= 0) voltStep = 0.1;
            const vTop = (0 - view.offsetY) / view.scaleY;
            let volt = Math.floor(vTop / voltStep) * voltStep;
             for(let i=0; i<2 * height; i++) {
                const y = volt * view.scaleY + view.offsetY;
                if (y > height + 10) break;
                if (y >= -10) {
                    const isZeroAxis = Math.abs(volt) < 1e-9;
                    ctx.strokeStyle = isZeroAxis ? '#00aaff' : '#444';
                    ctx.lineWidth = isZeroAxis ? 1 : 0.5;
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
                    if(!isZeroAxis) ctx.fillText(volt.toFixed(2), -8, y + 3);
                }
                volt -= voltStep;
                if (voltStep === 0 || !isFinite(voltStep)) break;
            }
        }

        function drawWaveform(width, height) {
            const waveColor = '#33ff99';
            const { startIndex, endIndex } = getVisibleDataIndices();
            const pointsInView = endIndex - startIndex;
            
            if (renderMode === 'minmax') {
                densityInfo.textContent = 'Auto';
                ctx.strokeStyle = waveColor; ctx.lineWidth = 1; ctx.beginPath();
                for (let px = 0; px < width; px++) {
                    const timeStartPx = (px - view.offsetX) / view.scaleX;
                    const timeEndPx = (px + 1 - view.offsetX) / view.scaleX;
                    const startIdx = Math.max(0, Math.floor((timeStartPx - startTime) / increment));
                    const endIdx = Math.min(allVoltages.length, Math.ceil((timeEndPx - startTime) / increment));
                    if (startIdx >= endIdx) continue;
                    let localMin = allVoltages[startIdx], localMax = allVoltages[startIdx];
                    for (let i = startIdx + 1; i < endIdx; i++) {
                        const v = allVoltages[i];
                        if (v < localMin) localMin = v;
                        if (v > localMax) localMax = v;
                    }
                    const y1 = localMin * view.scaleY + view.offsetY;
                    const y2 = localMax * view.scaleY + view.offsetY;
                    ctx.moveTo(px, y1); ctx.lineTo(px, y2);
                }
                ctx.stroke();
                return;
            }
            
            const baseDensity = width * 2;
            const maxDensity = pointsInView;
            const density = baseDensity + (maxDensity - baseDensity) * ((optimizationLevel - 1) / 99);
            const step = Math.max(1, Math.floor(pointsInView / density));
            const displayedPoints = Math.floor(pointsInView / step);
            densityInfo.textContent = `${displayedPoints.toLocaleString('pl-PL')} / ${pointsInView.toLocaleString('pl-PL')}`;

            if (renderMode === 'points') {
                ctx.fillStyle = waveColor;
                for (let i = startIndex; i < endIndex; i += step) {
                    const x = (startTime + i * increment) * view.scaleX + view.offsetX;
                    const y = allVoltages[i] * view.scaleY + view.offsetY;
                    ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
                }
            } else { // 'line' mode
                ctx.strokeStyle = waveColor; ctx.lineWidth = 1; ctx.beginPath();
                if (startIndex >= endIndex) return;
                let i = startIndex;
                let x = (startTime + i * increment) * view.scaleX + view.offsetX;
                let y = allVoltages[i] * view.scaleY + view.offsetY;
                ctx.moveTo(x, y);
                for (i = startIndex + step; i < endIndex; i += step) {
                    x = (startTime + i * increment) * view.scaleX + view.offsetX;
                    y = allVoltages[i] * view.scaleY + view.offsetY;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        // --- Logika Kursorów ---
        function toggleCursors() {
            cursors.enabled = !cursors.enabled;
            cursorsBtn.classList.toggle('active', cursors.enabled);
            measurementsPanel.style.display = cursors.enabled ? 'block' : 'none';
            draw();
        }
        function drawCursors(width, height) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ffa500'; // Czas
            const x1 = cursors.t1 * width;
            const x2 = cursors.t2 * width;
            ctx.beginPath(); ctx.moveTo(x1, 0); ctx.lineTo(x1, height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x2, 0); ctx.lineTo(x2, height); ctx.stroke();
            ctx.strokeStyle = '#9370db'; // Napięcie
            const y1 = cursors.v1 * height;
            const y2 = cursors.v2 * height;
            ctx.beginPath(); ctx.moveTo(0, y1); ctx.lineTo(width, y1); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, y2); ctx.lineTo(width, y2); ctx.stroke();
        }
        function updateMeasurementsPanel() {
            const { chartWidth, chartHeight } = getChartDimensions();
            const t1_val = (cursors.t1 * chartWidth - view.offsetX) / view.scaleX;
            const t2_val = (cursors.t2 * chartWidth - view.offsetX) / view.scaleX;
            const v1_val = (cursors.v1 * chartHeight - view.offsetY) / view.scaleY;
            const v2_val = (cursors.v2 * chartHeight - view.offsetY) / view.scaleY;
            const deltaT = Math.abs(t1_val - t2_val);
            const deltaV = Math.abs(v1_val - v2_val);
            const frequency = deltaT > 0 ? 1 / deltaT : 0;
            measurementsPanel.innerHTML = `
                ΔV: ${formatValue(deltaV, 'V')}<br>
                Δt: ${formatValue(deltaT, 's')}<br>
                ƒ: ${formatValue(frequency, 'Hz')}
            `;
        }

        // --- Logika Pomiarów Automatycznych ---
        function toggleAutoMeasurements() {
            autoMeasurements.enabled = !autoMeasurements.enabled;
            autoMeasureBtn.classList.toggle('active', autoMeasurements.enabled);
            autoMeasurementsPanel.style.display = autoMeasurements.enabled ? 'block' : 'none';
            draw();
        }
        function updateAutoMeasurementsPanel() {
            const { startIndex, endIndex } = getVisibleDataIndices();
            const originalData = allVoltages.slice(startIndex, endIndex);
            if (originalData.length < 2) {
                autoMeasurementsPanel.innerHTML = 'Zbyt mało danych';
                return;
            }
            const MAX_SAMPLES_FOR_ANALYSIS = 10000;
            let dataForAnalysis = originalData;
            let analysisIncrement = increment;
            if (originalData.length > MAX_SAMPLES_FOR_ANALYSIS) {
                const step = Math.floor(originalData.length / MAX_SAMPLES_FOR_ANALYSIS);
                dataForAnalysis = originalData.filter((_, i) => i % step === 0);
                analysisIncrement = increment * step;
            }
            let min = dataForAnalysis[0], max = dataForAnalysis[0], sum = 0, sumSq = 0;
            for (const v of dataForAnalysis) {
                if (v < min) min = v;
                if (v > max) max = v;
                sum += v;
                sumSq += v * v;
            }
            const avg = sum / dataForAnalysis.length;
            const rms = Math.sqrt(sumSq / dataForAnalysis.length);
            const vpp = max - min;
            const highThreshold = avg + vpp * 0.2;
            const lowThreshold = avg - vpp * 0.2;
            let state = 'looking_for_high';
            const periods = [];
            let lastUpCrossingIndex = -1;
            for (let i = 1; i < dataForAnalysis.length; i++) {
                const prev_v = dataForAnalysis[i-1];
                const curr_v = dataForAnalysis[i];
                if (state === 'looking_for_high' && prev_v < highThreshold && curr_v >= highThreshold) {
                    if (lastUpCrossingIndex !== -1) {
                        const periodInSamples = i - lastUpCrossingIndex;
                        periods.push(periodInSamples * analysisIncrement);
                    }
                    lastUpCrossingIndex = i;
                    state = 'looking_for_low';
                } else if (state === 'looking_for_low' && prev_v > lowThreshold && curr_v <= lowThreshold) {
                    state = 'looking_for_high';
                }
            }
            let avgPeriod = null;
            if (periods.length > 0) {
                avgPeriod = periods.reduce((a, b) => a + b, 0) / periods.length;
            }
            const frequency = avgPeriod ? 1 / avgPeriod : null;
            autoMeasurementsPanel.innerHTML = `
                Vpp: ${formatValue(vpp, 'V')}<br>
                Vmax: ${formatValue(max, 'V')}<br>
                Vmin: ${formatValue(min, 'V')}<br>
                Vavg: ${formatValue(avg, 'V')}<br>
                Vrms: ${formatValue(rms, 'V')}<br>
                Okres: ${formatValue(avgPeriod, 's')}<br>
                ƒ: ${formatValue(frequency, 'Hz')}
            `;
        }

        // --- Logika FFT ---
        function toggleFFT() {
            fftMode.enabled = !fftMode.enabled;
            fftBtn.classList.toggle('active', fftMode.enabled);
            fftControls.style.display = fftMode.enabled ? 'flex' : 'none';
            if (fftMode.enabled) {
                if (cursors.enabled) toggleCursors();
                if (autoMeasurements.enabled) toggleAutoMeasurements();
                cursorsBtn.disabled = true;
                autoMeasureBtn.disabled = true;
                calculateFFT();
                resetFFTView();
            } else {
                cursorsBtn.disabled = false;
                autoMeasureBtn.disabled = false;
                // Ukryj narzędzia FFT gdy tryb jest wyłączony
                if (fftPeaks.enabled) toggleFFTPeaks();
                fftPeaksPanel.style.display = 'none';
            }
            draw();
        }

        function toggleFFTPeaks() {
            fftPeaks.enabled = !fftPeaks.enabled;
            fftPeaksToggleBtn.classList.toggle('active', fftPeaks.enabled);
            fftPeaksControls.style.display = fftPeaks.enabled ? 'flex' : 'none';
            fftPeaksPanel.style.display = fftPeaks.enabled ? 'block' : 'none';
            if (fftPeaks.enabled) {
                findFFTPeaks();
            }
            draw();
        }

        function findFFTPeaks() {
            if (!fftMode.data) {
                fftPeaks.data = [];
                return;
            }
            const magnitudes = fftMode.data;
            const allPeaks = [];
            for (let i = 1; i < magnitudes.length - 1; i++) {
                if (magnitudes[i] > magnitudes[i - 1] && magnitudes[i] > magnitudes[i + 1]) {
                    allPeaks.push({ index: i, magnitude: magnitudes[i] });
                }
            }
            allPeaks.sort((a, b) => b.magnitude - a.magnitude);
            fftPeaks.data = allPeaks.slice(0, fftPeaks.num);
        }

        function updateFFTPeaksPanel() {
            if (!fftPeaks.enabled || fftPeaks.data.length === 0) {
                fftPeaksPanel.style.display = 'none';
                return;
            }
            fftPeaksPanel.style.display = 'block';
            const nyquist = (1 / fftMode.effectiveIncrement) / 2;
            const freqStep = nyquist / fftMode.data.length;
            let html = '<b>Wykryte piki:</b><br>';
            fftPeaks.data.forEach(peak => {
                const freq = peak.index * freqStep;
                html += `${formatValue(freq, 'Hz')}: ${peak.magnitude.toFixed(2)} dB<br>`;
            });
            fftPeaksPanel.innerHTML = html;
        }

        function calculateFFT() {
            const { startIndex, endIndex } = getVisibleDataIndices();
            const originalSamples = allVoltages.slice(startIndex, endIndex);
            if (originalSamples.length < 2) {
                fftMode.data = null;
                return;
            }
            
            const maxFreq = parseFloat(fftFreqInput.value) * parseInt(fftUnitSelect.value, 10);
            const requiredSamplingFreq = maxFreq * 2;
            const requiredIncrement = 1 / requiredSamplingFreq;
            
            const step = Math.max(1, Math.floor(requiredIncrement / increment));
            
            const samples = [];
            for (let i = 0; i < originalSamples.length; i += step) {
                samples.push(originalSamples[i]);
            }

            if (samples.length < 2) {
                fftMode.data = null;
                return;
            }
            
            fftMode.effectiveIncrement = increment * step;

            for(let i=0; i < samples.length; i++) {
                samples[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / (samples.length - 1)));
            }

            const N = 1 << Math.ceil(Math.log2(samples.length));
            const real = new Float32Array(N);
            const imag = new Float32Array(N);
            real.set(samples);

            let j = 0;
            for (let i = 0; i < N; i++) {
                if (i < j) { [real[i], real[j]] = [real[j], real[i]]; }
                let m = N >> 1;
                while (j >= m && m > 0) { j -= m; m >>= 1; }
                j += m;
            }
            for (let L = 2; L <= N; L <<= 1) {
                const M = L >> 1;
                const sr = Math.cos(Math.PI / M);
                const si = -Math.sin(Math.PI / M);
                let wr = 1, wi = 0;
                for (j = 0; j < M; j++) {
                    for (let i = j; i < N; i += L) {
                        const k = i + M;
                        const tr = wr * real[k] - wi * imag[k];
                        const ti = wr * imag[k] + wi * real[k];
                        real[k] = real[i] - tr;
                        imag[k] = imag[i] - ti;
                        real[i] += tr;
                        imag[i] += ti;
                    }
                    [wr, wi] = [wr * sr - wi * si, wr * si + wi * sr];
                }
            }

            const magnitudes = new Float32Array(N / 2);
            for (let i = 0; i < N / 2; i++) {
                const mag = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / N;
                magnitudes[i] = 20 * Math.log10(mag);
            }
            fftMode.data = magnitudes;
            if (fftPeaks.enabled) {
                findFFTPeaks();
            }
        }
        
        function resetFFTView() {
            const { chartWidth, chartHeight } = getChartDimensions();
            if (!fftMode.data) calculateFFT();
            if (!fftMode.data) return;

            const nyquist = (1 / fftMode.effectiveIncrement) / 2;
            fftView.scaleX = chartWidth / nyquist;
            fftView.offsetX = 0;

            let minDb = Infinity, maxDb = -Infinity;
            for (const v of fftMode.data) {
                if (isFinite(v)) {
                    if (v < minDb) minDb = v;
                    if (v > maxDb) maxDb = v;
                }
            }
            if (minDb === Infinity) { minDb = -100; maxDb = 0; }
            
            const dbRange = maxDb - minDb;
            fftView.scaleY = -chartHeight / (dbRange || 1);
            if (!isFinite(fftView.scaleY)) fftView.scaleY = -1;
            fftView.offsetY = -maxDb * fftView.scaleY;
        }

        function drawFreqAxis(width, height) {
            ctx.textAlign = "center";
            const freqRange = width / fftView.scaleX;
            const freqFit = getBestFreqFit(freqRange);
            let freqStep = Math.pow(10, Math.floor(Math.log10(freqRange))) / 10;
            if (freqStep <= 0) freqStep = 1;
            const firstFreq = -fftView.offsetX / fftView.scaleX;
            let freq = Math.ceil(firstFreq / freqStep) * freqStep;
            while (true) {
                const x = freq * fftView.scaleX + fftView.offsetX;
                if (x > width + 10) break;
                if (x >= -10) {
                    ctx.strokeStyle = '#444'; ctx.lineWidth = 0.5;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                    const labelValue = (freq * freqFit.multiplier).toFixed(2).replace(/\.00$/, '');
                    ctx.fillText(labelValue, x, height + 15);
                }
                freq += freqStep;
                if (freqStep === 0 || !isFinite(freqStep)) break;
            }
        }

        function drawDbAxis(width, height) {
            ctx.textAlign = "right";
            const dbRange = height / Math.abs(fftView.scaleY);
            let dbStep = Math.pow(10, Math.floor(Math.log10(dbRange))) / 2;
            if (dbStep < 1) dbStep = 1;
            if (!isFinite(dbStep)) dbStep = 10;

            const dbTop = (0 - fftView.offsetY) / fftView.scaleY;
            let db = Math.ceil(dbTop / dbStep) * dbStep;
            for (let i = 0; i < height * 2; i++) {
                const y = db * fftView.scaleY + fftView.offsetY;
                if (y > height + 10) break;
                if (y >= -10) {
                    ctx.strokeStyle = '#444'; ctx.lineWidth = 0.5;
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
                    ctx.fillText(db.toFixed(0), -8, y + 3);
                }
                db -= dbStep;
                if (dbStep === 0 || !isFinite(dbStep)) break;
            }
        }

        function drawFFT(width, height) {
            if (!fftMode.data) return;
            const magnitudes = fftMode.data;
            const nyquist = (1 / fftMode.effectiveIncrement) / 2;
            const freqStep = nyquist / magnitudes.length;
            
            ctx.strokeStyle = '#33ff99'; ctx.lineWidth = 1;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let i = 0; i < magnitudes.length; i++) {
                const freq = i * freqStep;
                const x = freq * fftView.scaleX + fftView.offsetX;
                
                if (x > width + 1) break; 
                if (x >= -1) {
                    const db = magnitudes[i];
                    if (isFinite(db)) {
                        const y = db * fftView.scaleY + fftView.offsetY;
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
            }
            ctx.stroke();

            // Draw peaks if enabled
            if (fftPeaks.enabled && fftPeaks.data.length > 0) {
                ctx.fillStyle = '#ff4444';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                fftPeaks.data.forEach(peak => {
                    const freq = peak.index * freqStep;
                    const x = freq * fftView.scaleX + fftView.offsetX;
                    const y = peak.magnitude * fftView.scaleY + fftView.offsetY;

                    if (x > 0 && x < width && y > 0 && y < height) {
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText(formatValue(freq, 'Hz'), x, y - 5);
                    }
                });
            }
        }

        init();
    </script>
</body>
</html>
